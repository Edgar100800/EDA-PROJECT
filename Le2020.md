The Thirty-Fourth AAAI Conference on Artiﬁcial Intelligence (AAAI-20)

Stochastically Robust Personalized
Ranking for LSH Recommendation Retrieval

Dung D. Le, Hady W. Lauw
School of Information Systems,
Singapore Management University
{ddle, hadywlauw}@smu.edu.sg

Abstract

Locality Sensitive Hashing (LSH) has become one of the
most commonly used approximate nearest neighbor search
techniques to avoid the prohibitive cost of scanning through
all data points. For recommender systems, LSH achieves ef-
ﬁcient recommendation retrieval by encoding user and item
vectors into binary hash codes, reducing the cost of exhaus-
tively examining all the item vectors to identify the top-
k items. However, conventional matrix factorization mod-
els may suffer from performance degeneration caused by
randomly-drawn LSH hash functions, directly affecting the
ultimate quality of the recommendations. In this paper, we
propose a framework named SRPR, which factors in the
stochasticity of LSH hash functions when learning real-
valued user and item latent vectors, eventually improving the
recommendation accuracy after LSH indexing. Experiments
on publicly available datasets show that the proposed frame-
work not only effectively learns user’s preferences for predic-
tion, but also achieves high compatibility with LSH stochas-
ticity, producing superior post-LSH indexing performances as
compared to state-of-the-art baselines.

1

Introduction

Matrix factorization (MF) gives rise to a widespread class
of techniques for recommender systems (Koren, Bell, and
Volinsky 2009). Deployment of MF-based recommender
system typically involves two phases: learning and retrieval.
• The learning phase analyzes historical feedback to learn
users’ preferences (e.g., ratings, clicks). Fundamentally,
a MF-based method derives a latent vector xu ∈ Rd for
each user u, and a latent vector yi ∈ Rd for each item i,
where d is the dimensionality. The degree of preference of
T yi.
user u for item i is modeled as the inner product xu
• The retrieval phase seeks to arrive at a personalized rec-
ommendation list for a target user u using the vectors
learnt from the learning phase. To do so, we identify the
top-k items according to preference scores xu
In both phases, we are concerned with the measures
of recommendation accuracy and computational efﬁciency.
The learning phase is concerned with efﬁciency in terms of

T yi.

Copyright c(cid:2) 2020, Association for the Advancement of Artiﬁcial
Intelligence (www.aaai.org). All rights reserved.

learning time. In most cases, learning algorithms can be run
ofﬂine. Meanwhile there have been works on algorithms that
learn from large datasets with millions of users and items.

Just as essential is the retrieval phase, which has received
relatively less attention in the literature. This latter phase is
just as sensitive (if not more) to efﬁciency, but of a different
sort, namely latency of retrieval. A target user would expect
retrieval of her personalized recommendation list in real-
time. A naive approach that scans all items to select the top-k
most relevant ones would incur per-query cost of O(n × d),
which scales linearly with the number of items n and the
number of factors d. Given an enormous catalogue of candi-
date items, such exhaustive approach may not achieve truly
real-time performance. On the other hand, precomputing the
top-k for all users would be impractical given the storage
costs involved for all the precomputed lists, as well as the
rigidity built into those lists that may affect the system’s
adaptability to drifting user preferences. Having a faster al-
ternative for top-k recommendation retrieval is desirable.

LSH Recommendation Retrieval. In face of these chal-
lenges, recent approaches turn to indexing schemes to over-
come the prohibitive cost of performing exhaustive top-k
recommendation search for each user. In particular, one of
the most popular such schemes is Locality-Sensitive Hash-
ing (LSH) (Shrivastava and Li 2015; Bachrach et al. 2014;
Fraccaro, Paquet, and Winther 2016; Le and Lauw 2017;
Hsieh et al. 2017; Liu and Wu 2016; Koenigstein and Ko-
ren 2013; Qi et al. 2017; Smirnov and Ponomarev 2014). In
the prevalent binary variant, LSH approximates relative dis-
tances between data points, by computing the Hamming dis-
tance between the corresponding codes, and hashing similar
data points to similar codes with high probability. Section 2
gives an overview of LSH-based recommendation retrieval.
There are signiﬁcant advantages to using LSH as an
indexing scheme for recommendation retrieval. By using
hashcodes, we can quickly retrieve a small subset of items
likely contain the k ”most relevant” items to the
that
query (user), because computing Hamming distance in-
volves mainly bitwise operations. Hashing-based indexing
provides provably sub-linear algorithms for search which is
beneﬁcial for large scale systems where even linear search
algorithms are impractical due to latency. Unlike spatial

4594

partitioning techniques, both the running time and the ac-
curacy guarantee of LSH are independent of the dimen-
sionality of the data. Hashing-based indexing schemes are
also massively parallelizable. This makes LSH suitable for
large-scale distributed processing system dealing with high-
dimensional datasets now common in modern applications.
Problem. As LSH is inherently stochastic, there is in-
evitable loss of information due to randomized hash func-
tions. There are two reasons. For one, binary LSH may suf-
fer from large variances in its estimation of the similarity
between data points (Ji et al. 2012). For another, data points
may be distributed non-uniformly over the space. Some
hashcodes may be shared by disproportionately many items.
For recommender system in particular, due to these vari-
ances, the output vectors of the learning algorithm might not
be well-aligned with the structural property of LSH, i.e., the
hashcodes may not preserve the ranking of original vectors,
causing signiﬁcant degeneration of recommendation accu-
racy post-indexing. To achieve better similarity estimation of
point-wise similarity and data space approximation, longer
codes (more hash functions) are needed, which is in conﬂict
with the original objective of speeding up retrieval.

Approach. There are several possible directions to get
around the potential lack of compatibility between a recom-
mendation algorithm and LSH hash functions. One is to by-
pass the hash functions altogether and to learn binary codes
directly, but this transfers the efﬁciency issue to the learning
phase as such methods may require solving NP-hard discrete
optimization problems (see Section 4). Another direction,
which we follow here, is to learn a “better” set of user/item
vectors that achieve greater compatibility with LSH.

In particular, we trace the compatibility issue to the
stochastic nature of the randomized hash functions. We will
explore this in greater depth in Section 3.1. In essence, the
variance due to the probabilistic hash functions may end up
violating the preferences expressed by the user and item vec-
tors from the learning phase. To alleviate the resulting per-
formance degeneration, we explore the idea of deriving user
and item representations that are robust to the stochasticity
of LSH, such that the post-LSH hashcodes would still pre-
serve the rankings by the original vectors with high proba-
bility. We achieve this ”LSH-friendly” property by incorpo-
rating the stochasticity of LSH in the learning phase.

Contributions. Firstly, to our best knowledge, we are the
ﬁrst to factor the stochasticity of LSH in learning user/item
latent vectors. This is based on an analysis of the effect
of LSH stochasticity on recommendation retrieval in Sec-
tion 3.1. Secondly, we propose a probabilistic framework
SRPR that optimizes for the recommendation accuracy post-
LSH indexing in Section 3.2, accommodating two widely-
adopted LSH families, i.e., sign random projection and L2-
LSH. Thirdly, we conduct comprehensive experiments on
public datasets to validate the effectiveness of our proposed
framework against baselines in Section 5.

2 LSH Recommendation Retrieval
Figure 1 illustrates a recommendation retrieval process
based on LSH, consisting of two distinct phases. One phase,
which could be ofﬂine, is the learning phase. In this phase,

Matrix
Factorization

(cid:4)(cid:10)(cid:6)(cid:9)(cid:1)(cid:3)(cid:5)(cid:11)(cid:9)(cid:7)(cid:12)(cid:1)(cid:10)(cid:3)

(cid:2)(cid:11)(cid:6)(cid:8)(cid:1)(cid:3)(cid:5)(cid:11)(cid:9)(cid:7)(cid:12)(cid:1)(cid:11)(cid:3)

(cid:14)(cid:16) (cid:14)(cid:17)

(cid:14)(cid:6)

(cid:15)(cid:16) (cid:15)(cid:17)

(cid:15)(cid:7)

(cid:4)
(cid:4)
(cid:4)

(cid:4)

(cid:4)

(cid:16)

(cid:17)

(cid:12)

(cid:4)
(cid:4)
(cid:4)

(cid:4)

(cid:4)

(cid:16)

(cid:17)

(cid:12)

(cid:16)

(cid:17)

(cid:12)

(cid:4)

(cid:9)(cid:13)
(cid:14)(cid:13)

(cid:4)(cid:10)(cid:22)(cid:15)(cid:1)(cid:3)(cid:24)(cid:19)(cid:11)(cid:23)(cid:16)(cid:20)(cid:19)(cid:22)
(cid:5)(cid:20) (cid:21) (cid:22)(cid:1)(cid:18)(cid:2) (cid:1)(cid:19)(cid:2) (cid:4) (cid:2) (cid:1)(cid:20)(cid:23)

(cid:9)(cid:22)(cid:13)(cid:21)(cid:1)(cid:13) (cid:6)(cid:8)(cid:4)(cid:1)(cid:2)(cid:20)(cid:12)(cid:13)

Phase II
LSH Top-k Retrieval

(cid:5)(cid:23)(cid:13)(cid:18)(cid:1)(cid:6)(cid:8)(cid:4)(cid:1)(cid:2)(cid:20)(cid:12)(cid:13)(cid:22)

Hash Tables
or
Hamming Ranking

Phase I
Learning Phase

Candidate Set
(For Hamming Ranking,
(cid:8)(cid:13) includes all items)

(cid:8)(cid:13)

(cid:2)(cid:10)(cid:19)(cid:12)(cid:16)(cid:12)(cid:10)(cid:23)(cid:13)(cid:1)
(cid:7)(cid:10)(cid:19)(cid:17)(cid:16)(cid:19)(cid:14)

Top-k items

Figure 1: LSH Recommendation Retrieval

we presume that an MF-based method, e.g., (Rendle et al.
2009; Salakhutdinov and Mnih 2007), derives a latent vec-
tor xu ∈ Rd for each user u, and a latent vector yi ∈ Rd for
each item i. The other phase, commonly online, is the top-
k recommendation retrieval. In this phase, before observing
any recommendation request, a set of bit functions hb =
(h1, h2, . . . , hb) are drawn from a LSH family and used to
map each item vector yi into a binary code hb(yi) ∈ {0, 1}b.
With the hashcodes in place, we could pursue one of two

possible search strategies as outlined below:
• Hamming Ranking: Given a user u, we hash xu to get
the hashcode hb(xu). We then measure the Hamming dis-
tances between hb(xu) and the hashcode of every item
hb(yi), ∀1 ≤ i ≤ n, and keep the k items with the small-
est Hamming distances. Technically, this still requires
scanning all items. In practice, Hamming ranking with
simple XOR operations is much more efﬁcient than ex-
haustive search with real-valued vectors.

• LSH Hash Tables: In this alternative, we organize items
of the same hashcode into a bucket. Upon the appearance
of a target user u, we hash xu into hb(xu). The candidate
set Cu consists of items from the hash table of the same
hashcode. A ranking process is performed on Cu to arrive
at the top-k based on the inner product computation on the
original real-valued vectors. The speedup comes from the
fact that Cu is expected to be a small subset of all items.
In Section 5, we will experiment with both search strategies.

3 Stochastically Robust Personalized

Ranking

For high quality top-k recommendations with LSH, the
hashcodes should preserve the ranking induced by vectors
from the learning phase. However, since the hash functions
are randomly drawn, the LSH codes may not reﬂect the or-
der of the real-valued vectors. In Section 3.1, we analyze the
stochastic properties of LSH hash functions in detail, which
underpins the proposal to factor in the structural property of
LSH in the learning phase as described in Section 3.2.

4595

3.1 Analysis of LSH Stochasticity
One important notion in the following analysis is a quantity
pui, which is the probability that a hash function results in
different hash values for xu and yi, i.e., pui = Pr(h(xu) (cid:5)=
h(yi)). For locality-sensitive hash functions, this probability
is inversely proportional to the similarity between data vec-
tors, i.e., pui ∝
sim(xu,yi) (Shrivastava and Li 2015). For
xu, yi, yj in Rd, we can estimate the probability that their
LSH codes would preserve the correct ordering as follows.
H is the num-

(cid:2)
(cid:2)hb(xu) − hb(yi)

The Hamming distance

(cid:2)
(cid:2)

1

ber of positions 1 ≤ l ≤ b that hl(xu) (cid:5)= hl(yi), i.e.,

(cid:2)
(cid:2)hb(xu) − hb(yi)

(cid:2)
(cid:2)

(cid:3)

H =

1≤l≤b

zl
ui,

in which zl

ui = 1 if hl(xu) (cid:5)= hl(yi) and 0 otherwise.

It is straightforward to see that zl

ui, 1 ≤ l ≤ b are
binary random variables following the Bernoulli distribu-
tion parameterized by success probability pui. Since the
hash functions h1, h2, . . . , hb are independent of one an-
other,
ui therefore fol-
lows the binomial distribution with mean bpui and variance
bpui(1 − pui), which can be approximated by a normal dis-
tribution with same mean and variance, i.e.,

(cid:2)
(cid:2)hb(xu) − hb(yi)

1≤l≤b zl

H =

(cid:4)

(cid:2)
(cid:2)

(cid:2)
(cid:2)hb(xu) − hb(yi)

(cid:2)
(cid:2)

∼ Normal (bpui, bpui(1 − pui)) (1)

H

As the difference between two normal distributions is also a
normal distribution, we thus have:
(cid:2)
(cid:2)
(cid:2)hb(xu) − hb(yj)
(cid:2)hb(xu) − hb(yi)

−
∼N (bpuj − bpui, bpuj(1 − puj) + bpui(1 − pui))

uij =

(2)

λb

(cid:2)
(cid:2)

(cid:2)
(cid:2)

H

H

i.e., λb
uij follows the normal distribution with mean b(puj −
pui) and variance b(puj(1 − puj) + pui(1 − pui)). From Eq.
2, we have the following lemma.
Lemma 1 Without loss of generality, assume that xu is
closer to yi than to yj, i.e, sim(xu, yi) > sim(xu, yj). The
probability that their hashcodes preserve the correct rank-
ing order is:

Pr

(cid:5)(cid:2)
(cid:2)hb(xu) − hb(yj)
√

(cid:7)

(cid:2)
(cid:2)

>

H

(cid:2)
(cid:2)hb(xu) − hb(yi)
(cid:9)

(cid:2)
(cid:2)

H

(cid:6)

= Φ

(cid:8)

b(puj − pui)
puj(1 − puj) + pui(1 − pui)

,

(3)

in which, Φ is the cummulative distribution function of the
standard normal distribution.
Proof: From Equation 2, we have the following analysis:
(cid:2)
(cid:2)hb(xu) − hb(yi)

(cid:5)(cid:2)
(cid:2)hb(xu) − hb(yj)

Pr

>

(cid:2)
(cid:2)

(cid:2)
(cid:2)

(cid:6)

H

H

(cid:9)

(cid:7)

˜λb
uij >

= Pr

(cid:7)

(cid:8)

˜λb

uij =
(cid:7)

(cid:8)

−b(puj − pui)
b(puj(1 − puj) + pui(1 − pui))
λb
uij − b(puj − pui)
b(puj(1 − puj) + pui(1 − pui))
(cid:9)

(cid:9)

∼ N (0, 1)

= Φ

(cid:8)

b(puj − pui)
b(puj(1 − puj) + pui(1 − pui))

(4)

4596

Insights. Lemma 1 reveals several insights. Firstly, a large
denominator puj(1−puj)+pui(1−pui) would likely lead to
erroneous ranking between xu, yi, yj using their hash codes.
That binary LSH usually suffers from large variances (Ji et
al. 2012) is a concern. One deceptively simple solution, also
the second insight, is to substantially increase code length b,
b increases the probability in Lemma 1 to preserve the
as
original ranking. However, the resulting code may contain
redundant bits. It also consumes more computations to the
contrary of the speedup objective. Thirdly, if the quantity

√

γuij =

(cid:8)

puj − pui
puj(1 − puj) + pui(1 − pui)

(5)

is large enough, it is more likely that the hashcodes will
preserve the ranking (lessening the need for longer codes).
Since γuij is deﬁned over trainable vectors xu, yi, yj, we can
learn these vectors to maximize γuij so that their LSH codes
would in turn preserve the ranking better. Importantly, this
third insight is the basis for our proposed framework to be
elaborated in the next section.

3.2 Factoring LSH Stochasticity in Learning

To achieve concise yet informative binary codes, we take
into account the stochasticity of LSH functions when learn-
ing user and item vectors. The objective is to derive a repre-
sentation that is robust to the stochasticity of LSH functions
so that the hashcodes would preserve the ranking of original
items with high probability.

Input. To build such representation, we learn from ordinal
preference observations. The input that we consider is a set
of triples T ⊂ U ×I ×I, where U and I are sets of users and
items respectively. A triple tuij ∈ T relates one user u ∈ U
and two different items i, j ∈ I, indicating u’s preferring
item i to item j. From ratings, we can induce an ordinal triple
for each instance when user u rates item i higher than she
rates item j (Le and Lauw 2017). Triples can also model the
implicit feedback (Rendle et al. 2009).

Output. The goal is to derive a d-dimensional latent vec-
tor xu ∈ Rd for each user u ∈ U (denoted X collectively for
U ), and a latent vector yi ∈ Rd for each item i ∈ I (denoted
Y collectively for I), that not only capture the user prefer-
ence accurately pre-hashing, but also ensure that their post-
hashing codes would preserve the ranking established by
the real-valued latent representation with high probability. In
other words, for a triple tuij, hb are expected to produce hash
codes with a smaller Hamming distance between hb(xu)
and hb(yi) than the Hamming distance between hb(xu) and
(cid:2)
(cid:2)
hb(yj), i.e.,

(cid:2)
(cid:2)hb(xu) − hb(yj)

(cid:2)
(cid:2)hb(xu) − hb(yi)

>

(cid:2)
(cid:2)

H .

H

Triplet Likelihood. A crucial component is how the latent
vectors of users and items would generate the ordinal triplet
comparisons in T . The principle relating a triple tuij is: if u
prefers i to j, the probability of the event that the Hamming
distance between the hashcode of xu and yi is smaller than
that between xu and yj is as high as possible. From Lemma
1, that is equivalent to having the quantity γuij (Eq. 5) to be
as positive as possible. We therefore propose to formulate

the probablity of triples tuij in terms of γuij as in Eq. 6.

(cid:10)√

(cid:11)

,

(cid:10)√

bγuij

bγuij

P(tuij|xu, yi, yj) = Φ

(6)
For each observed triple tuij, we want to maximize the like-
(cid:11)
lihood probability Φ
, which is equivalent to max-
imizing γuij. Interestingly, as puj moves towards 1 and pui
moves towards 0, the value of γuij keeps increasing. Hence
as we learn X and Y to maximize γuij for each tuij ∈ T , a
user would be located closer to her more preferred items (pui
is low) as compared to less preferred items (puj is high).

Objective Function. Given the set of triples T and the
number of intended LSH functions b, ﬁnd the set of user co-
ordinates X and item coordinates Y , such that the following
sum of the log-likelihood-probabilities is maximized:
(cid:3)

(cid:10)

(cid:11)

√

L = max
X,Y

ln

Φ(

tuij ∈T

bγuij)

(7)

There are two widely-adopted LSH schemes, Sign Ran-
dom Projection and L2-LSH. We describe how SRPR could
accommodate them, creating two variants: SRPR-SRP and
SRPR-L2.

Sign Random Projection. SRP-LSH (Charikar 2002) is a
LSH scheme for angular similarity, i.e., sim(xu, yi) = 1 −
˚cos−1

. The SRP-LSH hash function is:

xT

(cid:10)

(cid:11)

u yi
||xu||||yi||

a (x) = sign(aT x);
hsrp
(8)
in which, the parameter a is random vector chosen with each
component from i.i.d normal. The corresponding probability
of xu, yi having different hash values is:

psrp
ui = Pr(hsrp

a (xu) (cid:2)= hsrp

a (yi)) =

1
π

. cos−1

(cid:2)

(cid:3)

xT
u yi
||xu||.||yi||

, (9)

L2-LSH. L2-LSH is the LSH scheme for L2 distance
(Datar et al. 2004), whose hash function is deﬁned as:

hsrp
a,b(x) = (cid:10)

aT x + b
r

(cid:11);

(10)

where, r is the window size, a is the random vector with
each component from i.i.d normal, i.e, ai ∼ Normal(0, 1),
and a scalar b ∼ Uni(0, r). The probability of two points
x, y having different hash values under L2-LSH function is:

(cid:4)

pl2
ui = Pr
(cid:2)

2Φ

−

r
dui

(cid:5)

a,b(yi)

hl2
a,b(xu) (cid:2)= hl2
(cid:3)
1

)

+

(cid:6)

(2π)(r/dui)

=
(cid:2)

(cid:2)

1 − exp

−(

r
dui

)2/2

(11)

(cid:3)(cid:3)

where, Φ(x) is cumulative probability function of normal
distribution and dui = ||xu − yi|| is the L2 distance between
xu, yi. In this study, we use r = 2.5 as in (Shrivastava and
Li 2014).

Parameter Learning. The learning algorithm for SRPR
framework is based on gradient ascent. It ﬁrst initializes the
user and item latent vectors with each coordinate drawn
from normal standard distribution. In each iteration, the
model parameters are updated based on the gradients, with
a decaying learning rate (cid:4) over time. The time complex-
ity of the algorithm is linear to the number of triples in T ,
i.e., O(|T |), which is similar to that of triple-based methods
(Rendle et al. 2009), (Le and Lauw 2017).

4597

4 Related Work
LSH for Maximum Inner Product Search (MIPS). (Shri-
vastava and Li 2014) claims the infeasible existence of LSH
scheme for MIPS. A workaround is to transform MIPS into
Nearest Neighbor Search (NNS) (Shrivastava and Li 2014)
or Maximum Cosine Similarity Search (MCSS) (Shrivas-
tava and Li 2015) by augmenting user and item vectors
into higher-dimensional space. Later, (Neyshabur and Sre-
bro 2015) achieves better performance by extending the out-
put latent vectors by one dimension to equalize the magni-
tude of item vectors. However, (Huang et al. 2018) points
out that even the vector transformation in (Neyshabur and
Srebro 2015) suffers from large distortion error in reducing
MIPS to NNS, and proposes Query Normalized First (QNF)
transformation to reduce the distortion and achieve better
performance. In the experiment we compare to the compo-
sition of ranking-based MF method BPR followed by QNF
transformation, code-named BPR-QNF.

Indexable Representation. Another approach is to ob-
viate the need for transformation by modelling the user-
item interaction with a proper metric distance. For instance,
CFEE (Khoshneshin and Street 2010) ﬁts a rating ˆrui in
terms of the squared Euclidean distance between xu and yi,
i.e., ˆrui ∝ ||xu − yi||2. COE (Le and Lauw 2016) seeks
to ensure that an item i liked by a user u would be placed
closer to the user on the Euclidean representation than a less
preferred item j. For COE and CFEE, the retrieval of top
recommendations becomes nearest neighbor search (NNS).
IPMF (Fraccaro, Paquet, and Winther 2016) keeps the clas-
sic formulation of matrix factorization, but incorporates ad-
ditional constraint that all item vectors have the same mag-
nitude. IBPR (Le and Lauw 2017) proposes the use of an-
gular distance kernel, evaluated as the arccos of the inner
product between the normalized vectors, to model pairwise
ordinal preferences. These methods however does not take
into account the LSH stochasticity. In Section 5, we com-
pare SRPR to IPMF, IBPR, CFEE, and COE to validate our
stochasticity-robust representations.

Discrete Representation. Discrete representation meth-
ods (Zhou and Zha 2012), (Zhang et al. 2016), (Zhang,
Lian, and Yang 2017) attempt to directly represent each
user/item by a binary code. Quantization-based discretiza-
tion such as (Zhang et al. 2014) adopts a two-stage process:
constraining the learning process and applying a binary-
quantization algorithm to generate the code from the learned
real-valued vectors. Optimization-based discretization such
as DCF (Zhang et al. 2016), DPR (Zhang, Lian, and Yang
2017) adopt classic matrix factorization formulations, while
imposing further constraints on balance and decorrelation
for the binary codes. Learning binary codes may require
solving a NP-hard discrete optimization problem. Different
from stochastic LSH, disrete representation learning is de-
terministic and data-dependent. We compare to PPH, DCF,
and DPR in Section 5.

Data-Independent Hashing. (Jin et al. 2014), (Park, Ca-
farella, and Mozafari 2015), (Ji et al. 2012) propose different
designs for the hash functions that are sensitive to the den-
sity or the neighborhood structure of the data, effectively re-
ducing the variance of the similarity estimation of the hash-

#users

#items

#ratings

Movielens 20M 138493
480189
Netﬂix

27278
17770

20000263
100480507

#training
ordinal triples
5.46 × 108
2.29 × 1010

Table 1: Dataset Statistics

codes. These developments are orthogonal to us, as we are
interested in deriving the vector representation from prefer-
ence data that are robust to LSH stochasticity.

5 Experiments

5.1 Experiment Setting

Datasets. We experiment on two large public datasets:
MovieLens 20M1 and Netﬂix2 (Table 1). By default, Movie-
Lens 20M includes users with at least 20 ratings. For con-
sistency, we apply the same to Netﬂix. We randomly keep
60% of the ratings for training and hide 40% for testing in
a stratiﬁed manner. We report the average results over ﬁve
such random training/testing splits. We generate a triple tuij
if user u has higher rating on item i than on item j with i, j,
and these triples are formed within the training set only.

Comparative Methods. For SRPR-SRP and SRPR-L2,
after learning the representations, we produce the hashcodes
using SRP-LSH and L2-LSH respectively. We experiment
with 10 different sets of LSH functions, and the average re-
sults are reported in Tables 2 and 3. For the LSH itself, we
use the implementation in (Aly, Munich, and Perona 2011).
We consider the following categories of baselines.

LSH-Indexed Baselines:
• BPR-QNF: BPR (Rendle et al. 2009), followed by trans-

formation in (Huang et al. 2018).

• CFEE, COE: Euclidean embedding methods that ﬁts rat-
ings (Khoshneshin and Street 2010) and ordinal triples
(Le and Lauw 2016) respectively.

• IPMF: matrix factorization that learns ﬁxed-length item

vectors (Fraccaro, Paquet, and Winther 2016).

• IBPR: a development of BPR with the use of arccos ker-
nel for indexable representation (Le and Lauw 2017).

Comparing to these LSH-indexed methods allows us to
prove the effectiveness of factoring in the stochasticity of
LSH when learning user and item vectors.

Discrete Representation:
• PPH (Zhang et al. 2014): a two-step quantization-based

discretization method.

• DCF , DPR : optimization-based discretization methods
that ﬁts ratings (Zhang et al. 2016) and ordinal triples
(Zhang, Lian, and Yang 2017) respectively.

Comparing to PPH, DCF, and DPR would validate the ben-
eﬁt of learning real-valued vectors that are robust to LSH
stochasticity as compared to learning the binary vectors.

1http://grouplens.org/datasets/movielens/20m/
2http://academictorrents.com/details

/9b13183dc4d60676b773c9e2cd6de5e5542cee9a

We tune the hyper-parameters of all models for the best
performances. For IPMF, we adopt the setting used for Net-
ﬂix dataset. For the ranking-based methods (BPR, COE,
IBPR and SRPR), the learning rate and the regularization
are 0.05 and 0.001 respectively. For CFEE, these values
are 0.1 and 0.001 respectively. All LSH-indexed models use
d = 20 dimensionalities in their latent representations. Sim-
ilar trends are observed with other dimensionalities.

5.2 Comparing to LSH-Indexed Baselines

Hamming Ranking. To investigate how well the ranking in-
duced by the hashcodes preserve the ordering of observed
test ratings, we measure nDCG (Normalized Discounted
Cummulative Gain) with Hamming Ranking search strategy.
For LSH-indexed models, we measure nDCG on LSH codes
(Absolute LSH nDCG) and its relative ratio to nDCG of orig-
inal vectors (Relative LSH nDCG).

Table 2 shows the performances of all models with k = 10
for MovieLens 20M (top panel) and Netﬂix (bottom panel).
The second column, Brute Force nDCG@10, presents the
nDCG@10 with linear scanning for all models with d = 20.
SRPR-based models consistently show better Absolute LSH
nDCG@10 values compared to the baselines across different
number of bits b for both datasets. This implies that the LSH
codes of SRPR models are more compact and informative as
compared to those of the baselines. Also, the Relative LSH
nDCG@10s of SRPR-based models are higher than other
methods and are closest to 1, showing that SRPR is more
robust to the stochasticity of LSH, resulting in LSH codes
that preserve the ranking of the original vectors with greater
ﬁdelity.

Hash Tables. When using hash tables for top-k retrieval,
one speciﬁes the number of tables T and the code length
b. We experiment with various values of T , and T = 10
returns the best performances for all models. We also vary
the number of hash functions b and larger b is expected to
lead to fewer items in each bucket.

The hash table approach processes only a subset of items
to produce the top-k, which in the test set may include both
rated and unrated items. In practice, we are interested in
whether a user’s most preferred items could be found in the
top-k. We deﬁne preferred items as those with maximum
rating. For each user u with at least one highest rating item
in the test set, we compute the percentage of these that are
returned in the top-k. The higher the percentage, the better
is the model at identifying the items a user prefers the most.
Eq. 12 presents the formula for Recall@k:

Recall@k =

1
|Umax|

(cid:7)

u∈Umax

|{i ∈ ψu
k : rui = max rating}|
|{i ∈ I : rui = max rating}|

, (12)

in which Umax is the set of users with at least one item with
max rating and ψu
k is the returned top-k. We exclude train-
ing items for u from both numerator and denominator. We
normalize Recall@k with the ideal Recall@k value that an
algorithm can achieve, and denote the metric as nRecall@k.
Figure 2(a) shows the nRecall@k using hash table lookup
with T = 10 tables and different values of code length
b = 4, 8, 12, 16 for MovieLens 20M. Across the b’s, the
trends are similar. SRPR has the highest nRecall@k values

4598

Brute Force
nDCG@10 (d = 20)
-

0.703
0.698
0.715
0.751
0.753
0.750
0.752

0.625
0.654
0.644
0.772
0.767
0.759
0.762

8

0.582
0.605
0.646
0.640
0.679
0.684
0.697

0.541
0.570
0.519
0.600
0.650
0.650
0.675

b

CFEE
COE
BPR-QNF
IPMF
IBPR
SRPR-L2
SRPR-SRP

CFEE
COE
BPR-QNF
IPMF
IBPR
SRPR-L2
SRPR-SRP

Absolute
LSH nDCG@10
32

16

64
MovieLens 20M
0.586
0.610
0.698
0.641
0.734
0.736
0.739

0.585
0.608
0.678
0.647
0.721
0.721
0.729

0.582
0.609
0.661
0.651
0.703
0.710
0.715

0.561
0.565
0.514
0.621
0.695
0.702
0.708

Netﬂix

0.562
0.575
0.511
0.649
0.714
0.722
0.730

0.564
0.575
0.513
0.684
0.738
0.740
0.744

128

8

0.587
0.611
0.718
0.653
0.742
0.741
0.745

0.565
0.578
0.514
0.712
0.744
0.749
0.752

0.828
0.867
0.895
0.861
0.901
0.912
0.927

0.867
0.872
0.806
0.776
0.848
0.856
0.886

Relative
LSH nDCG@10
32

64

16

0.829
0.872
0.911
0.880
0.934
0.947
0.950

0.897
0.865
0.798
0.803
0.906
0.925
0.929

0.832
0.870
0.905
0.904
0.957
0.961
0.970

0.899
0.880
0.794
0.840
0.932
0.951
0.958

0.834
0.873
0.896
0.930
0.975
0.981
0.983

0.901
0.880
0.796
0.886
0.963
0.975
0.976

128

0.836
0.875
0.913
0.957
0.985
0.988
0.991

0.904
0.884
0.798
0.921
0.971
0.987
0.987

Table 2: Absolute LSH nDCG@10 and Relative LSH nDCG@10 (as b varies) - Hamming Ranking

b = 4

(a) MovieLens 20M

b = 8

0.06

0.05

0.04

0.02

0.01

0.00

0.06

0.05

0.04

0.02

0.01

0.00

b = 12

0.06

0.05

0.04

0.02

0.01

0.00

b = 16

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

k

b = 4

k

b = 12

k

b = 8

(b) Netflix

0.25

0.20

0.15

0.10

0.05

0.00

0.25

0.20

0.15

0.10

0.05

0.00

0.25

0.20

0.15

0.10

0.05

0.00

k

b = 12

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

(cid:4)

(cid:2)(cid:1)

(cid:2)(cid:4)

(cid:3)(cid:1)

k

k

k

k

0.06

0.05

0.04

0.02

0.01

0.00

0.25

0.20

0.15

0.10

0.05

0.00

Figure 2: nRecall@k (k = 5, 10, 15, 20) with Locality Sensitive Hashing (T =10 Hash Tables)

across all k. It outperforms BPR-QNF that conducts vec-
tor transformation as post-processing, which indicates that
learning inherently stochastically robust vectors is helpful.
Interestingly, SRPR and IBPR perform better than other ma-
trix factorization models that ﬁt ratings IPMF and CFEE,
suggesting that learning from relative comparisons may be
more suitable for top-k recommendation. Figure 2(b) shows
the results for Netﬂix. Similarly, SRPR also shows higher
nRecall@k values across all k, except that IBPR is more
competitive when b = 4, though still lower than SRPR.

Accuracy-Efﬁciency Tradeoff. Another metric speedup

is to investigate the efﬁciency of using LSH hash tables.
Retrieval time taken by exhaustive search
Retrieval time taken by the index

Speedup =

.

(13)
We investigate the tradeoff between the speedup achieved
and the accuracy of the top-k returned by the hash tables.

Figure 3 shows the nRecall@10 values and the speedup with
different number of hash functions b. When given the same
desired speedup, SRPR achieves higher performance com-
pared to the baselines. Also, given the same desired accu-
racy level, SRPR returns the highest speedup rate. Gener-
ally, for all models, the accuracy descreases and the speedup
increases as b increases. This is expected, as the longer the
codes, the smaller the set of candidates returned by the hash
tables on which we need to compute the similarity scores.

5.3 Comparing to Discrete Representation

To validate the effectiveness of learning LSH-friendly vec-
tors over learning the binary codes directly, we compare our
SRPR models to the three discrete learning baselines: PPH,
DCF, and DPR on Hamming ranking. Table 3 shows the
nDCG@10s. For both MovieLens 20M and Netﬂix, SRPR-
SRP’s performances are signiﬁcantly better than the three

4599

0.025

0.020

0
1

@

l
l
a
c
e
R
n

0.015

0.010

0.005

0.000

0.090

0.075

0.060

0.045

0.030

0.015

0.000

0
1

@

l
l
a
c
e
R
n

(a) MovieLens 20M

b = 4

b = 4

b = 4

b = 8

b = 8

b = 12

b=16

b = 4

b = 8

b =12

b =16

b = 12

b = 4

b = 16

b = 8

b = 12

(cid:2)(cid:1)(cid:6)(cid:1)(cid:3)(cid:1)

(cid:2)(cid:1)(cid:6)(cid:1)(cid:3)(cid:1)

(cid:2)(cid:1)(cid:5)(cid:1)(cid:3)(cid:4)

(cid:2)(cid:1)(cid:6)(cid:1)(cid:5)(cid:1)

b = 16

1

2

4

(cid:2)(cid:1)(cid:6)(cid:1)(cid:5)(cid:1)

8
16
32
Speedup (log scale)

(b) Netflix

b = 16
(cid:2)(cid:1)(cid:5)(cid:1)(cid:3)(cid:4)

64

128

b = 12

(cid:2)(cid:6)(cid:2)(cid:4)(cid:1)

256

b = 4

b = 8

b = 12

b=16

b = 4

b = 8

b = 12

b = 4 b = 8

b =12

b =16

(cid:2)(cid:1)(cid:6)(cid:1)(cid:3)(cid:1)

b = 4

(cid:2)(cid:1)(cid:6)(cid:1)(cid:5)(cid:1)
b = 8

(cid:2)(cid:1)(cid:6)(cid:1)(cid:3)(cid:1)

1

2

4

8

16

32

64

Speedup (log scale)

b = 16

b = 4

(cid:2)(cid:1)(cid:5)(cid:1)(cid:3)(cid:4)

(cid:2)(cid:1)(cid:6)(cid:1)(cid:2)(cid:4)(cid:1)

b = 12

b = 16

(cid:2)(cid:1)(cid:5)(cid:1)(cid:3)(cid:4)
128

(cid:2)(cid:6)(cid:2)(cid:4)(cid:1)
256

512

Figure 3: nRecall@10 vs. Speedup (T =10 LSH Tables)

compared baselines. The values in the parentheses indicate
the percentages of improvement of SRPR as compared to the
best discrete model DPR. We intuit two possible reasons.
For one, LSH-indexed methods have richer representation
space than discrete representation methods. For another, as
SRPR’s vectors are compatible with LSH, the loss of recom-
mendation accuracy caused by LSH is alleviated.

5.4 Top-k Recommendations without LSH

As the purpose of LSH is to approximate the proximity
between the real-valued vectors learnt from the underlying
preference models, the quality of LSH-based top-k recom-
mendations may be inherited from and bounded by that of
original vectors. In this section, we measure the nDCG and
nRecall values of all models with linear scanning to better
understand the quality of the learnt vectors.

Figure 4 shows the nDCG@10 and nRecall@10 values
for the two datasets at various d. We observe that SRPR
consistently outperforms the baselines in terms of nRe-
call@10 across dimensions. SRPR is also among the best,
with the most competitive baselines in terms of nDCG@10
being IBPR and IPMF, which do not take into account LSH
stochasticity. This shows that incorporating LSH stochastic-
ity has not hurt the ranking performance in the original vec-
tor space, while improving the post-LSH performance.

4600

b

8

16

32

64

128

PPH
DCF
DPR
SRPR-L2
(d = 20) + LSH
SRPR-SRP
(d = 20) + LSH

PPH
DCF
DPR
SRPR-L2
(d = 20) + LSH
SRPR-SRP
(d = 20) + LSH

0.627
0.641
0.652
0.684
(+4.9%)
0.697
(+6.9%)

0.581
0.635
0.644
0.650
(+0.9%)
0.675
(+4.9%)

MovieLens 20M

0.635
0.655
0.663
0.710
(+7.1%)
0.715
(+7.8%)

Netﬂix

0.544
0.660
0.673
0.702
(+4.3%)
0.708
(+5.2%)

0.640
0.660
0.674
0.721
(+7.0%)
0.729
(+8.2%)

0.556
0.681
0.679
0.722
(+6.3%)
0.730
(+7.4%)

0.642
0.662
0.682
0.736
(+7.9%)
0.739
(+8.3%)

0.560
0.709
0.713
0.740
(+3.8%)
0.744
(+4.3%)

0.650
0.667
0.694
0.741
(+6.7%)
0.745
(+7.3%)

0.578
0.726
0.732
0.749
(+2.3%)
0.752
(+2.7%)

Table 3: SRPR versus Discrete Representation (nDCG@10)

(a.1) nDCG@10

(b.1) nDCG@10

0.8

0.75

0.7

0.65

0.6

10

30

50

70

90

10

30

50

70

90

d

(a.2) nRecall@10

d

(b.2) nRecall@10

0.04

0.03

0.02

0.01

0

0.78

0.75

0.72

0.69

0.66

0.08

0.06

0.04

0.02

0

10

30

50

70

90

10

30

50

70

90

d
(a) MovieLens 20M

d
(b) Netflix

Figure 4: Top-10 Recommendations with Linear Scanning

6 Conclusion
In this paper, we deal with efﬁcient recommendation re-
trieval with LSH. Our framework, namely SRPR, factors in
the stochasticity of LSH when learning vector representa-
tions of users/items from ordinal triples. SRPR produces a
representation that is robust to the stochasticity of LSH, re-
sulting in signiﬁcant gain in retrieval efﬁciency, while still
maintaining high accuracy for top-k recommendations.

Acknowledgments
This research is supported by the National Research Founda-
tion, Prime Minister’s Ofﬁce, Singapore under its NRF Fel-
lowship Programme (Award No. NRF-NRFF2016-07).

References
Aly, M.; Munich, M.; and Perona, P. 2011. Indexing in large
scale image collections: Scaling properties and benchmark.
In WACV, 418–425. IEEE.
Bachrach, Y.; Finkelstein, Y.; Gilad-Bachrach, R.; Katzir, L.;
Koenigstein, N.; Nice, N.; and Paquet, U. 2014. Speeding

Thieme, L. 2009. Bpr: Bayesian personalized ranking from
implicit feedback. In UAI, 452–461. AUAI Press.
Salakhutdinov, R., and Mnih, A. 2007. Probabilistic matrix
factorization. In NIPS, NIPS’07, 1257–1264. USA: Curran
Associates Inc.
Shrivastava, A., and Li, P. 2014. Asymmetric lsh (alsh) for
In
sublinear time maximum inner product search (mips).
NIPS, 2321–2329.
Shrivastava, A., and Li, P. 2015. Improved asymmetric lo-
cality sensitive hashing (alsh) for maximum inner product
search (mips). In UAI, 812–821. Arlington, Virginia, United
States: AUAI Press.
Smirnov, A., and Ponomarev, A. 2014. A hybrid peer-to-
peer recommendation system architecture based on locality-
sensitive hashing.
In Proceedings of 15th Conference of
Open Innovations Association FRUCT, 119–125. IEEE.
Zhang, Z.; Wang, Q.; Ruan, L.; and Si, L. 2014. Preference
preserving hashing for efﬁcient recommendation. In SIGIR.
Zhang, H.; Shen, F.; Liu, W.; He, X.; Luan, H.; and Chua, T.-
S. 2016. Discrete collaborative ﬁltering. In SIGIR, 325–334.
ACM.
Zhang, Y.; Lian, D.; and Yang, G. 2017. Discrete person-
alized ranking for fast collaborative ﬁltering from implicit
feedback. In AAAI.
Zhou, K., and Zha, H. 2012. Learning binary codes for
collaborative ﬁltering. In KDD, 498–506.

up the xbox recommender system using a euclidean transfor-
mation for inner-product spaces. In RecSys, 257–264. ACM.
Charikar, M. S. 2002. Similarity estimation techniques from
rounding algorithms. In Proceedings of the Thiry-fourth An-
nual ACM Symposium on Theory of Computing, STOC ’02,
380–388. New York, NY, USA: ACM.
Datar, M.; Immorlica, N.; Indyk, P.; and Mirrokni, V. S.
2004. Locality-sensitive hashing scheme based on p-stable
distributions. In Proceedings of the Twentieth Annual Sym-
posium on Computational Geometry, SCG ’04, 253–262.
New York, NY, USA: ACM.
Fraccaro, M.; Paquet, U.; and Winther, O. 2016. Indexable
probabilistic matrix factorization for maximum inner prod-
uct search. In AAAI, 1554–1560.
Hsieh, C.-K.; Yang, L.; Cui, Y.; Lin, T.-Y.; Belongie, S.; and
Estrin, D. 2017. Collaborative metric learning. In WWW,
193–201.
Huang, Q.; Ma, G.; Feng, J.; Fang, Q.; and Tung, A. K. H.
2018. Accurate and fast asymmetric locality-sensitive hash-
In KDD,
ing scheme for maximum inner product search.
1561–1570.
Ji, J.; Li, J.; Yan, S.; Zhang, B.; and Tian, Q. 2012. Super-bit
locality-sensitive hashing. In NIPS, 108–116.
Jin, Z.; Li, C.; Lin, Y.; and Cai, D. 2014. Density sensi-
tive hashing. IEEE transactions on cybernetics 44(8):1362–
1371.
Khoshneshin, M., and Street, W. N. 2010. Collaborative
ﬁltering via euclidean embedding. In RecSys, 87–94. ACM.
Koenigstein, N., and Koren, Y. 2013. Towards scalable and
accurate item-oriented recommendations.
In RecSys, Rec-
Sys ’13, 419–422.
Koren, Y.; Bell, R.; and Volinsky, C. 2009. Matrix fac-
torization techniques for recommender systems. Computer
42(8):30–37.
Le, D. D., and Lauw, H. W. 2016. Euclidean co-embedding
of ordinal data for multi-type visualization. In SDM, 396–
404. SIAM.
Le, D. D., and Lauw, H. W. 2017. Indexable bayesian per-
sonalized ranking for efﬁcient top-k recommendation.
In
CIKM, 1389–1398. ACM.
Liu, C.-L., and Wu, X.-W. 2016. Fast recommendation
on latent collaborative relations. Knowledge-Based Systems
109:25 – 34.
Neyshabur, B., and Srebro, N. 2015. On symmetric and
asymmetric lshs for inner product search. In ICML, 1926–
1934. JMLR.org.
Park, Y.; Cafarella, M.; and Mozafari, B. 2015. Neighbor-
sensitive hashing. Proc. VLDB Endow. 9(3):144–155.
Qi, L.; Xiang, H.; Dou, W.; Yang, C.; Qin, Y.; and Zhang,
X. 2017. Privacy-preserving distributed service recommen-
dation based on locality-sensitive hashing.
In 2017 IEEE
International Conference on Web Services (ICWS), 49–56.
Los Alamitos, CA, USA: IEEE Computer Society.
Rendle, S.; Freudenthaler, C.; Gantner, Z.; and Schmidt-

4601


